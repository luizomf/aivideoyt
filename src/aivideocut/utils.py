# pyright: basic

from collections.abc import Generator, Iterable
from datetime import datetime
from io import StringIO
from pathlib import Path
from typing import Literal, TypeAlias

from rich import print as rprint
from whisper.utils import WriteSRT

from aivideocut.configs import (
    ANY_SPACE_RE,
    DOUBLE_LINE_RE,
    ENDING_DOT_RE,
    ONE_LINE_RE,
)

SpeechTimestamp: TypeAlias = dict[Literal["start"] | Literal["end"], float]
SpeechTimestamps: TypeAlias = list[SpeechTimestamp]


class SRTStringWriter(WriteSRT):
    def __init__(self) -> None:
        super().__init__("")

    def write_result(self, result: dict) -> str:
        s = StringIO()
        super().write_result(result, file=s)
        return s.getvalue().strip()


def ajust_vad_speech_timestamps(
    speech_timestamps: SpeechTimestamps,
    min_speech_length_secs: float = 1,
    pad_start_secs: float = 0.02,
    pad_end_secs: float = 0.03,
) -> SpeechTimestamps:
    new_timestamps: SpeechTimestamps = []

    if not speech_timestamps:
        return new_timestamps

    first_timestamp_start = speech_timestamps[-0]["start"]
    last_timestamp_end = speech_timestamps[-1]["end"]

    last_current_start = -1
    last_current_end = 0
    for timestamp in speech_timestamps:
        current_start, current_end = timestamp.values()
        found_last_end = False

        if pad_start_secs > 0:
            current_start = max(last_current_end, current_start - pad_start_secs)

        if pad_end_secs > 0:
            current_end = min(last_timestamp_end, current_end + pad_end_secs)

        if last_current_start < 0:
            last_current_start = current_start

        if current_start == last_current_end:
            continue

        current_duration = current_end - last_current_start
        is_current_duration_accepted = current_duration >= min_speech_length_secs
        last_end_not_found = not found_last_end

        if found_last_end and not is_current_duration_accepted:
            last_current_start = current_start

        if last_end_not_found and is_current_duration_accepted:
            new_speech_timestamp: SpeechTimestamp = {
                "start": last_current_start,
                "end": current_end,
            }
            new_timestamps.append(new_speech_timestamp)
            found_last_end = True
            last_current_start = -1
            last_current_end = current_end

    if not new_timestamps:
        new_timestamps.append(
            {"start": first_timestamp_start, "end": last_timestamp_end}
        )
    else:
        new_timestamps[-1]["end"] = last_timestamp_end

    rprint(
        "\n"
        f"Reduced from {len(speech_timestamps)} cuts generated by IA "
        f"to {len(new_timestamps)} cuts base on `adjust_speech_timestamps` "
        "configs: \n"
        f"\tmin_speech_length_secs = {min_speech_length_secs}\n"
        f"\tpad_start_secs = {pad_start_secs}\n"
        f"\tpad_end_secs = {pad_end_secs}"
        "\n"
    )

    return new_timestamps


def yield_text_by_char_qtd(
    text_blocks: Iterable[str], max_chars: float = float("inf")
) -> Generator[list[str]]:
    qtd_chars = 0
    limited_blocks: list[str] = []

    for block in text_blocks:
        if qtd_chars >= max_chars and limited_blocks:
            yield limited_blocks
            limited_blocks = []
            qtd_chars = 0

        qtd_chars += len(block)
        limited_blocks.append(block)

    if limited_blocks:
        yield limited_blocks


def smart_text_split(
    text: str, approx_max_chars: float = float("inf")
) -> Generator[str]:
    text_length = len(text)

    remaining_text = ""

    for i in range(0, text_length, int(approx_max_chars)):
        start = i
        end = int(min(text_length, i + approx_max_chars))

        text_chunk = f"{remaining_text}{text[start:end]}"
        chunk_length = len(text_chunk)

        new_end = end
        for j in range(chunk_length - 1, -1, -1):
            match = ENDING_DOT_RE.search(text_chunk[j])
            if match:
                new_end = j + 1
                break

        yield (text_chunk[:new_end].strip())

        remaining_text = text_chunk[new_end:].strip()

    if remaining_text:
        yield remaining_text.strip()


def split_srt_blocks(srt: str, max_chars: float = float("inf")) -> Generator[list[str]]:
    blocks: list[str] = DOUBLE_LINE_RE.split(srt.strip())
    return yield_text_by_char_qtd(blocks, max_chars=max_chars)


def extract_text_from_srt(srt: str) -> str:
    blocks = split_srt_blocks(srt, 1)

    srt_txt = ""
    for block in blocks:
        block_lines = ONE_LINE_RE.split(block[0])

        if not block_lines or len(block_lines) < 3:
            continue

        block_text_lines = " ".join(block_lines[2:])
        block_text = ONE_LINE_RE.sub(" ", block_text_lines)
        block_text = ANY_SPACE_RE.sub(" ", block_text)
        srt_txt += f"{block_text} "

    return srt_txt


def read_file_path(path: Path) -> str:
    with path.open("r", encoding="utf-8") as f:
        return f.read()


def write_str_to_file(
    content: str, path: Path, *, create_parents: bool = False
) -> None:
    if create_parents:
        path.parent.mkdir(parents=True, exist_ok=True)

    with path.open("w", encoding="utf-8") as f:
        f.write(content)


def get_today_path(separator: str = "-") -> Path:
    now = datetime.now()
    s = separator
    return Path(f"{now:%Y{s}%m{s}%d{s}%H{s}%M{s}%S{s}%f}")


def add_timestamp_to_path(path: Path, separator: str = "") -> Path:
    stem = path.stem
    suffix = path.suffix
    now = datetime.now().strftime(f"%Y%m%d{separator}%H%M%S{separator}%f")
    new_path = path.with_name(f"{stem}{separator}{now}{suffix}")
    return new_path.resolve()


def create_file_path(
    *,
    full_filename: str,
    parent: Path,
    unique_filename: bool = False,
    today_parent: bool = False,
    separator: str = "",
) -> Path:
    file_path = (parent / full_filename).resolve()

    if today_parent:
        today_path = get_today_path(separator)
        file_path = (parent / today_path / full_filename).resolve()

    if unique_filename:
        file_path = add_timestamp_to_path(file_path, separator=separator)

    return file_path.resolve()
